const fs = require('fs');
const path = require('path');

// 项目根目录
const ROOT_PATH = path.join(__dirname, 'smart-code-agent-full-package');

// 1. 批量创建所有文件夹
const folders = [
  'docs',
  'src/bin',
  'src/agent/main',
  'src/agent/demand-analyst',
  'src/agent/observer',
  'src/skills',
  'src/utils',
  'src/assets/question-lib',
  'src/assets/templates/demand-report',
  'src/assets/templates/code',
  'src/assets/templates/observer-report',
  'src/assets/rules',
  'src/config',
];

folders.forEach(folder => {
  const fullPath = path.join(ROOT_PATH, folder);
  fs.mkdirSync(fullPath, { recursive: true });
  console.log(`创建文件夹: ${fullPath}`);
});

// 2. 定义所有文件内容
const files = {
  // 根目录配置文件
  'package.json': JSON.stringify({
    "name": "smart-code-agent",
    "version": "1.0.0",
    "description": "智能代码规范化自动生成工具，全链路需求闭环、标准化、自动化、高可用",
    "main": "dist/index.js",
    "bin": { "sca": "dist/bin/index.js" },
    "scripts": {
      "dev": "tsc --watch",
      "build": "tsc",
      "lint": "eslint src/**/*.ts",
      "lint:fix": "eslint src/**/*.ts --fix",
      "format": "prettier --write src/**/*.ts",
      "test": "jest",
      "prepare": "npm run build"
    },
    "keywords": ["code-generator", "code-standard", "agent", "cli", "dev-tools"],
    "author": "",
    "license": "MIT",
    "engines": { "node": ">=16.0.0" },
    "dependencies": {
      "commander": "^11.1.0",
      "inquirer": "^8.2.6",
      "chalk": "^4.1.2",
      "handlebars": "^4.7.8",
      "eslint": "^8.57.0",
      "prettier": "^3.2.5",
      "better-sqlite3": "^9.4.3",
      "uuid": "^9.0.1",
      "jest": "^29.7.0"
    },
    "devDependencies": {
      "@types/node": "^20.11.0",
      "@types/inquirer": "^8.2.10",
      "@types/uuid": "^9.0.7",
      "@types/better-sqlite3": "^7.6.9",
      "@typescript-eslint/eslint-plugin": "^7.0.0",
      "@typescript-eslint/parser": "^7.0.0",
      "typescript": "^5.3.3"
    }
  }, null, 2),

  'tsconfig.json': JSON.stringify({
    "compilerOptions": {
      "target": "ES2020",
      "module": "CommonJS",
      "outDir": "./dist",
      "rootDir": "./src",
      "strict": true,
      "esModuleInterop": true,
      "skipLibCheck": true,
      "forceConsistentCasingInFileNames": true,
      "resolveJsonModule": true,
      "declaration": true,
      "sourceMap": true
    },
    "include": ["src/**/*"],
    "exclude": ["node_modules", "dist", "test"]
  }, null, 2),

  '.eslintrc.js': `module.exports = {
  parser: '@typescript-eslint/parser',
  extends: [
    'eslint:recommended',
    'plugin:@typescript-eslint/recommended'
  ],
  parserOptions: {
    ecmaVersion: 2020,
    sourceType: 'module'
  },
  rules: {
    'no-console': 'off',
    '@typescript-eslint/no-explicit-any': 'warn',
    '@typescript-eslint/no-unused-vars': ['error', { argsIgnorePattern: '^_' }],
    'prefer-const': 'error'
  },
  env: {
    node: true,
    jest: true
  }
};`,

  '.prettierrc': JSON.stringify({
    "semi": true,
    "singleQuote": true,
    "tabWidth": 2,
    "trailingComma": "es5",
    "printWidth": 120,
    "arrowParens": "always"
  }, null, 2),

  '.gitignore': `# 依赖
node_modules/

# 构建输出
dist/
build/

# 日志
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# 本地数据
data/
*.db
*.db-wal
*.db-shm
snapshots/

# 环境变量
.env
.env.local
.env.*.local

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# 操作系统
.DS_Store
Thumbs.db

# 测试覆盖率
coverage/
.nyc_output/`,

  // 文档类文件
  'docs/00-项目README.md': `# Smart Code Agent
智能代码规范化自动生成工具，以「需求前置闭环、主Agent唯一调度、Skills插件化执行、观察者全链路监控」为核心架构，实现从模糊需求到可上线规范代码的全链路自动化、标准化、高可用交付。

## 核心定位
- 唯一中枢：主Agent为全流程唯一调度中心，绝对不搞多Agent自由通信
- 需求闭环：专业需求分析+用户确认，从源头杜绝需求偏差与返工
- 高可用：全流程异常兜底、自动自愈，绝对不卡死、不中断
- 标准化：代码规范、需求文档、测试用例全链路标准化
- 可观测：观察者Agent旁路全链路监控，为系统迭代提供数据支撑

## 核心架构
\`\`\`
交互层（CLI）→ 主Agent（唯一调度中枢）→ Skills插件化执行 → 资源层
                          ↓
                    全链路异步事件总线
                          ↓
                    观察者Agent（旁路只读）
\`\`\`

## 目录结构
详见 \`项目目录结构说明书.md\`

## 开发规范
所有开发必须严格遵守 \`04-项目开发规范与编码准则\`、\`05-接口协议与数据结构刚性规范\`，绝对禁止突破职责边界。

## 快速开始
1. 安装依赖：\`npm install\`
2. 本地开发：\`npm run dev\`
3. 构建打包：\`npm run build\`
4. 本地链接测试：\`npm link\`

## 版本管理
- 版本规则：\`v{主版本}.{次版本}.{补丁版本}\`
- 主版本：架构/核心需求重大变更
- 次版本：新增功能模块
- 补丁版本：bug修复、优化`,

  'docs/01-产品需求文档(PRD) V3.1 最终定稿版.md': `# 产品需求文档（PRD）V3.1 最终定稿
## 文档信息
| 项目 | 内容 |
|------|------|
| 产品名称 | Smart Code Agent |
| 文档版本 | V3.1 最终定稿 |
| 修订日期 | 2026-02-21 |
| 生效日期 | 2026-02-21 |
| 文档状态 | 开发前锁定，非评审流程禁止修改 |

---

## 一、产品定位
### 1.1 核心定位
一款面向开发者与研发团队的**工业化、高可用、全链路标准化**的代码生成与研发提效工具，通过「**精准需求采集→专业需求分析→用户确认闭环→智能调度编码→全流程测试验证→标准化交付**」的完整链路，解决需求模糊、理解偏差、代码不规范、流程易中断、返工率高的核心研发痛点。

### 1.2 核心理念（宪法级，禁止突破）
1.  **唯一中枢原则**：主Agent是全流程唯一调度中心，指令发起权仅归主Agent所有
2.  **需求闭环原则**：需求未经用户100%确认，绝对不进入编码执行环节
3.  **高可用原则**：全流程异常兜底、自动自愈，绝对不卡死、不中断、不崩溃
4.  **标准化原则**：需求文档、代码规范、测试用例、交付物全链路标准化
5.  **只读隔离原则**：观察者Agent仅旁路监听，绝对不干预主流程、不修改任何数据
6.  **单一职责原则**：每个模块/Skill仅负责单一职责，禁止越权、禁止职责交叉

### 1.3 目标用户
- 个人前端/后端/全栈开发者
- 追求代码规范统一、研发效率提升的中小型研发团队
- 承接外包需求、需要标准化需求与交付的开发人员

### 1.4 核心解决痛点
1.  需求模糊零散，开发前无专业分析，需求理解偏差导致高返工率
2.  代码风格混乱、规范不统一，团队协作成本高、可维护性差
3.  代码生成工具流程不可控，易报错、卡死、中断，无法落地生产环境
4.  测试无标准、无闭环，交付质量不可控
5.  系统迭代无数据支撑，只能被动响应用户反馈，无法主动优化

---

## 二、核心功能模块（刚性范围，开发期禁止新增）
### 模块一：需求分析闭环模块（需求分析师Agent负责）
#### 1.1 关键信息精准采集
- 自动识别用户初始需求类型（页面开发/接口开发/组件封装/项目初始化）
- 匹配对应场景的「最少必要关键问题库」，仅提问核心信息，无冗余提问
- 自动校验信息完整性，缺失必填信息自动补充提问
- 采集信息结构化存储，存入demand命名空间只读上下文

#### 1.2 专业需求分析与报告生成
- 基于采集信息，生成标准化《需求分析报告》，固定包含：需求背景、核心目标、功能范围、技术要求、验收标准、边界条件、风险提示
- 需求分析阶段同步生成可量化的验收测试用例，每个验收标准对应至少1条可执行测试用例
- 自动识别需求矛盾点、不可实现点、边界模糊点，提前给出预警与建议

#### 1.3 用户确认闭环
- 向用户完整推送《需求分析报告》与验收测试用例
- 仅提供「确认通过」/「需求调整」双选项，流程无歧义
- 确认通过：需求报告自动标记为只读，存入上下文，进入主Agent调度环节
- 需求调整：引导用户输入修改意见，回流到对应环节迭代优化，重新发起确认

### 模块二：主Agent核心调度模块（唯一调度中枢）
#### 2.1 全流程状态机管控
- 基于有限状态机（FSM）管控全流程流转，状态流转规则唯一，无模糊跳转
- 每个状态定义准入准出标准、最大重试次数、异常兜底策略
- 全流程状态可追溯、可中断、可恢复

#### 2.2 任务拆解与规划
- 基于确认后的需求报告，拆解为线性可执行的任务步骤队列
- 每个任务明确：执行目标、调用Skill、输入参数、输出标准、超时时间
- 任务拆解严格遵循「无依赖并行、有依赖串行」的原则

#### 2.3 Skill调度与执行管控
- 按任务队列顺序/并行调度对应Skill，严格遵循标准化输入输出协议
- 全流程异常捕获，根据异常类型触发重试/降级/回滚策略
- 每个Skill执行结果强制校验，不符合标准的禁止进入下一个环节

#### 2.4 全链路上下文管理
- 分阶段命名空间存储上下文，严格控制读写权限
- 只读上下文全局共享，禁止任何修改；可写上下文仅授权模块可修改
- 每完成一个状态自动保存快照，支持中断后从断点恢复

#### 2.5 配置与快照管理
- 统一管理全局配置、用户自定义配置，标准化传递给所有Skill
- 定期保存流程状态快照，持久化到本地，支持中断恢复、版本回退

### 模块三：Skills插件化执行模块
所有Skill继承统一BaseSkill基类，单一职责、可插拔、可扩展，仅能通过主Agent调度执行。

| Skill名称 | 核心职责 | 准入标准 | 准出标准 |
|-----------|----------|----------|----------|
| code-generate.skill | 基于需求报告生成代码初稿与单元测试用例 | 确认后的只读需求报告 | 代码初稿生成完成、单元测试用例生成完成 |
| error-fix.skill | 代码语法/逻辑错误检测、自动修复、安全降级 | 代码初稿 | 代码无语法错误、不可修复问题安全降级、不影响运行 |
| code-format.skill | 代码标准化格式化、规范统一、注释补充 | 修复后的代码 | 代码符合预设规范、0规范错误、注释完整 |
| unit-test.skill | 执行单元测试，输出测试报告 | 标准化后的代码 | 单元测试通过率100%、测试报告生成完成 |
| file-io.skill | 代码文件按项目结构写入本地磁盘 | 测试通过的代码 | 文件写入完成、路径正确、可正常访问 |
| integration-test.skill | 依赖检查、项目编译/启动检查、基础功能验证 | 文件写入完成 | 依赖可正常安装、项目可正常启动、基础功能无异常 |
| acceptance-test.skill | 基于预设验收用例执行验收测试，输出报告 | 集成测试通过 | 验收测试通过率100%、验收报告生成完成 |

### 模块四：观察者Agent旁路监控模块
#### 4.1 全链路事件监听
- 基于异步事件总线，单向订阅全流程所有事件，无阻塞、不干预主流程
- 事件合法性校验、按traceId聚合全链路事件，形成完整链路视图
- 全链路事件持久化存储，可追溯、可回溯

#### 4.2 规则化问题识别
- 基于预设规则引擎，自动识别系统运行中的能力不足、错误逻辑、低效行为、异常风险
- 规则可配置、可扩展，无需修改核心代码即可新增分析规则
- 识别到的问题结构化存储，标记严重等级、根因分析

#### 4.3 全维度指标计算
- 自动计算系统运行核心指标：成功率、耗时、重试率、异常率、需求匹配率等
- 按模块、按周期聚合指标，形成量化数据体系
- 指标异常自动预警

#### 4.4 标准化报告输出
- 单次流程运行报告：单次全链路详情、指标、问题、优化建议
- 周期性系统迭代报告：周期内系统运行情况、高频问题、迭代优先级建议
- 专项分析报告：特定模块/问题的专项深度分析

### 模块五：CLI交互模块
- 命令行入口、全局命令注册、参数解析
- 流程状态实时展示、进度提示、日志输出
- 用户交互、确认操作、中断/恢复指令处理
- 报告查看、历史版本管理、配置修改入口

---

## 三、非功能需求（刚性要求）
1.  **稳定性**：全流程异常兜底，主流程可用率99.9%，绝对不出现卡死、崩溃、无限循环
2.  **性能**：单流程平均耗时≤5分钟，单Skill执行超时时间可配置，启动耗时≤3秒
3.  **兼容性**：兼容Windows/macOS/Linux全平台，兼容Node.js 16+ LTS版本
4.  **可扩展性**：新增技术栈/场景仅需新增模板，新增功能仅需新增Skill，无需修改核心框架
5.  **可观测性**：全流程日志完整、事件可追溯、指标可量化，出问题可快速定位根因
6.  **安全性**：所有数据本地存储，不上传任何外部服务，无用户业务敏感数据泄露风险

---

## 四、最终交付标准（刚性验收条件）
1.  全流程状态机流转正常，无模糊跳转、无死循环、无非法状态
2.  需求闭环完整，需求确认前不进入编码环节，需求报告只读不可修改
3.  主Agent调度逻辑正常，严格遵循职责边界，无越权执行业务逻辑
4.  所有Skill执行符合标准化协议，单一职责，无越权操作
5.  观察者Agent旁路运行正常，全链路监听无遗漏，不干预主流程
6.  全流程异常兜底正常，出现错误自动修复/降级，绝对不卡死、不崩溃
7.  测试闭环完整，单元测试/集成测试/验收测试自动化执行，通过率100%
8.  全链路上下文隔离正常，无数据污染、无越权修改
9.  中断恢复功能正常，工具崩溃/用户中断后，可从断点继续执行
10. 全平台兼容正常，可在Windows/macOS/Linux正常安装、运行、交付

---

## 五、需求变更管理规则
开发周期内，核心需求、架构、边界红线禁止变更；确需变更的，必须发起正式评审流程，全员确认通过后，更新PRD与相关文档，方可调整开发内容。`,

  'docs/02-系统架构设计说明书 最终版.md': `# 系统架构设计说明书 最终版
## 一、架构总览
### 1.1 架构设计原则
- 高内聚低耦合：模块职责单一，边界清晰，无交叉依赖
- 中心化调度：主Agent为唯一调度中枢，无多中枢冲突
- 旁路隔离：观察者Agent完全独立于主流程，只读不干预
- 插件化扩展：业务能力全部Skill化，可插拔、可扩展、可替换
- 高可用兜底：全链路异常捕获，任何环节失败都有兜底策略
- 可观测性：全链路事件、日志、指标可追溯、可量化

### 1.2 整体架构分层
\`\`\`
┌─────────────────────────────────────────────────────────────┐
│ 交互层（CLI）                                                │
│ 命令入口、用户交互、状态展示、报告查看、指令处理            │
└─────────────────────────┬───────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│ 主Agent层（唯一调度中枢）                                    │
│ 状态机引擎、任务规划器、执行调度器、异常兜底器              │
│ 上下文管理器、配置管理器、快照管理器                        │
└─────────────────────────┬───────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│ Skill层（插件化执行单元）                                    │
│ 需求分析Skill组、编码执行Skill组、测试验证Skill组          │
└─────────────────────────┬───────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│ 资源支撑层                                                    │
│ 模板库、规则库、测试用例库、事件总线、日志系统、存储系统    │
└─────────────────────────┬───────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│ 观察者Agent层（旁路只读）                                    │
│ 事件监听引擎、规则分析引擎、指标计算模块、报告生成模块      │
└─────────────────────────────────────────────────────────────┘
\`\`\`

## 二、核心模块详细设计
### 2.1 交互层
- 核心职责：用户与系统的唯一交互入口，负责指令接收、用户交互、结果展示
- 核心模块：
  - 命令解析模块：全局命令注册、参数解析、指令分发
  - 交互模块：用户提问、确认操作、选项选择的交互式处理
  - 展示模块：流程状态、进度、日志、报告的格式化输出
  - 指令处理模块：中断、恢复、版本回退、配置修改等指令处理
- 技术选型：Commander.js + Inquirer.js + Chalk

### 2.2 主Agent层（唯一调度中枢）
#### 2.2.1 状态机引擎
- 核心职责：全流程状态管控，刚性定义状态流转规则，禁止非法跳转
- 核心能力：状态初始化、状态流转校验、重试次数管控、异常状态处理、状态快照保存
- 状态定义：详见《03-全流程状态机与流转规则说明书》

#### 2.2.2 任务规划器
- 核心职责：将确认后的需求报告拆解为可执行的任务步骤队列
- 核心能力：需求结构化解析、任务拆解、依赖关系分析、并行/串行任务编排、任务参数标准化

#### 2.2.3 执行调度器
- 核心职责：按任务队列调度对应Skill执行，管控全流程执行节奏
- 核心能力：Skill动态加载、标准化输入输出、执行超时管控、执行结果校验、异常分发处理

#### 2.2.4 异常兜底器
- 核心职责：全流程异常捕获、分类处理、兜底策略执行
- 核心能力：异常分级分类、重试策略执行、降级处理、回滚操作、用户提示

#### 2.2.5 上下文管理器
- 核心职责：全链路上下文的存储、权限管控、更新、读取
- 核心设计：
  - 分阶段命名空间：init、demand、coding、testing、delivery，每个命名空间独立存储
  - 权限管控：每个模块仅能访问授权的命名空间，只读/可写权限严格隔离
  - 不可变设计：确认后的核心数据（如需求报告）标记为只读，禁止任何修改
  - 增量更新：仅更新变化字段，而非全量覆盖
  - 快照管理：每完成一个状态自动保存上下文快照，支持中断恢复

#### 2.2.6 配置管理器
- 核心职责：全局配置的统一管理、校验、分发
- 核心能力：默认配置加载、用户自定义配置合并、配置合法性校验、配置标准化分发、配置持久化

#### 2.2.7 快照管理器
- 核心职责：流程状态快照的保存、加载、清理
- 核心能力：快照自动保存、快照列表管理、快照加载恢复、快照持久化、快照清理归档

### 2.3 Skill层
#### 2.3.1 核心设计
- 所有Skill继承统一的BaseSkill基类，封装标准化的输入输出、格式校验、异常捕获逻辑
- 每个Skill仅负责单一职责，禁止越权操作、禁止跨模块调用
- Skill仅能通过主Agent调度，禁止主动发起任何操作、禁止修改非授权上下文
- 新增功能仅需新增Skill文件，无需修改主Agent核心代码，符合开闭原则

#### 2.3.2 BaseSkill基类设计
\`\`\`typescript
// 标准化输入接口
export interface SkillInput {
  config: Record<string, any>;
  context: {
    readOnly: Record<string, any>;
    writable: Record<string, any>;
  };
  task: Record<string, any>;
  snapshotPath: string;
  traceId: string;
}

// 标准化输出接口
export interface SkillOutput {
  code: 200 | 300 | 400 | 500; // 200成功 300需用户交互 400可重试失败 500不可重试失败
  data: Record<string, any>;
  message: string;
  nextAction?: string;
  needRollback?: boolean;
}

// 基类
export abstract class BaseSkill {
  public abstract readonly name: string;

  // 子类必须实现的核心执行方法
  protected abstract execute(input: SkillInput): Promise<SkillOutput>;

  // 输入格式校验
  protected validateInput(input: SkillInput): boolean {
    // 统一校验逻辑
  }

  // 输出格式校验
  protected validateOutput(output: SkillOutput): boolean {
    // 统一校验逻辑
  }

  // 统一执行入口
  public async run(input: SkillInput): Promise<SkillOutput> {
    try {
      if (!this.validateInput(input)) {
        return {
          code: 500,
          data: {},
          message: \`[\${this.name}] 输入格式校验失败\`,
        };
      }
      const output = await this.execute(input);
      if (!this.validateOutput(output)) {
        return {
          code: 500,
          data: {},
          message: \`[\${this.name}] 输出格式校验失败\`,
        };
      }
      return output;
    } catch (error) {
      return {
        code: 500,
        data: {},
        message: \`[\${this.name}] 执行异常: \${error.message}\`,
      };
    }
  }
}
\`\`\`

#### 2.3.3 Skill分组
| 分组 | Skill列表 | 核心职责 |
|------|-----------|----------|
| 需求分析Skill组 | demand-collect.skill、demand-analysis.skill、demand-confirm.skill | 需求采集、分析、确认闭环 |
| 编码执行Skill组 | code-generate.skill、error-fix.skill、code-format.skill、file-io.skill | 代码生成、修复、标准化、文件写入 |
| 测试验证Skill组 | unit-test.skill、integration-test.skill、acceptance-test.skill | 自动化测试执行、报告生成 |

### 2.4 资源支撑层
#### 2.4.1 模板库
- 需求分析报告模板、验收测试用例模板
- 各技术栈代码模板（React/Vue/Node/小程序等）
- 观察者报告模板

#### 2.4.2 规则库
- 代码规范规则（ESLint/Prettier/命名规范）
- 观察者分析规则库
- 错误自愈规则库
- 状态机流转规则

#### 2.4.3 全链路异步事件总线
- 核心职责：主流程事件的单向广播，观察者Agent的唯一数据来源
- 核心设计：
  - 完全异步非阻塞，事件发送不影响主流程
  - 单向通信，仅支持主流程→观察者的事件广播，禁止反向通信
  - 标准化事件格式，强制校验
  - 全局单例，无状态设计

#### 2.4.4 日志系统
- 核心职责：全链路日志的统一管理、分级存储、格式化输出
- 核心设计：
  - 分级日志：DEBUG/INFO/WARN/ERROR
  - 按traceId分文件存储，全链路可追溯
  - 日志自动脱敏，过滤业务敏感信息
  - 异步落盘，不阻塞主流程

#### 2.4.5 存储系统
- 核心职责：快照、日志、事件、报告、历史版本的持久化存储
- 技术选型：SQLite（本地轻量数据库，无需额外部署）+ 本地文件系统

### 2.5 观察者Agent层
- 核心定位：全链路旁路监控、问题识别、数据沉淀、迭代支撑，只读不干预主流程
- 核心模块：
  - 事件监听引擎：订阅事件总线，事件格式化、过滤、聚合
  - 规则分析引擎：基于预设规则，自动识别系统问题、根因分析
  - 指标计算模块：全链路量化指标计算、聚合、异常预警
  - 日志聚合模块：全链路日志聚合、归类、结构化存储
  - 报告生成模块：标准化报告生成、导出
  - 数据持久化模块：数据结构化存储、归档、查询

## 三、跨模块通信规则（刚性禁止突破）
### 3.1 唯一允许的两种通信模式
1.  **主Agent ↔ Skill：主Agent单向指令+标准化回执**
    - 仅主Agent可主动发起指令，Skill仅能被动响应
    - 所有通信必须通过标准化输入输出接口，禁止私下数据传递
    - 所有通信必须经过上下文管理器，严格遵守权限规则
    - 所有通信全链路留痕，同步写入日志与事件总线

2.  **主流程 → 观察者Agent：单向异步事件广播**
    - 仅主流程可单向广播事件，观察者仅能订阅接收
    - 禁止观察者向主流程回发任何指令、数据
    - 所有事件异步非阻塞发送，不影响主流程
    - 事件格式严格标准化，禁止传递业务敏感数据

### 3.2 绝对禁止的通信模式
- 禁止多Agent对等网状双向通信
- 禁止Skill之间直接通信，所有交互必须通过主Agent中转
- 禁止观察者Agent与任何主流程模块的双向通信
- 禁止模块之间不经过标准化通道的私下数据传递
- 禁止模块越权访问/修改其他模块的内存数据

## 四、异常处理与高可用设计
### 4.1 异常分级处理
| 异常等级 | 异常场景 | 处理策略 |
|----------|----------|----------|
| 轻微异常 | 非核心功能执行失败、警告类异常 | 记录日志，继续执行，不中断流程 |
| 可重试异常 | Skill执行超时、临时IO失败、偶发错误 | 按预设次数重试，重试成功继续执行，重试失败降级处理 |
| 可降级异常 | 非核心Skill执行失败、不影响主流程交付 | 降级跳过该步骤，记录警告，继续执行主流程 |
| 严重异常 | 核心Skill执行失败、主流程无法继续 | 触发回滚，提示用户，提供重试/恢复入口，绝对不卡死 |

### 4.2 中断与恢复设计
- 快照保存时机：每完成一个状态流转、每个Skill执行完成后、用户中断前
- 恢复流程：工具启动时自动检测未完成快照，提示用户是否从断点恢复
- 回滚设计：关键环节支持原子性回滚，回滚到上一个稳定状态

## 五、扩展性设计
- 新增技术栈/场景：仅需新增对应代码模板、需求问题库，无需修改核心代码
- 新增功能：仅需新增对应Skill文件，实现BaseSkill基类，主Agent自动识别调度
- 新增分析规则：仅需在观察者规则库新增规则配置，无需修改核心代码
- 新增配置项：仅需在配置管理器新增配置项，自动同步到所有Skill`,

  'docs/03-全流程状态机与流转规则说明书.md': `# 全流程状态机与流转规则说明书
## 一、状态机核心设计原则
1.  **线性流转为主**：全流程以线性流转为核心，仅允许规则内的回退，禁止无规则跳转
2.  **准入准出刚性**：每个状态有明确的准入条件和准出标准，不满足条件绝对禁止流转
3.  **重试次数限制**：每个状态定义最大重试次数，超过阈值禁止无限重试，避免死循环
4.  **全链路可追溯**：每次状态流转都有完整日志、事件记录，可回溯全流程流转路径
5.  **异常状态闭环**：所有异常状态都有明确的处理规则和出口，绝对不出现卡死、无响应状态

---

## 二、全流程状态定义与流转规则
| 状态编号 | 状态名称 | 状态描述 | 准入条件 | 触发事件 | 目标状态 | 最大重试次数 |
|----------|----------|----------|----------|----------|----------|--------------|
| S0 | 初始化 | 主Agent启动，初始化上下文、配置、日志系统、事件总线、观察者Agent | 无 | 用户输入初始需求，CLI指令校验通过 | S1 | 1次 |
| S1 | 需求采集 | 调用demand-collect.skill，完成需求关键信息采集 | S0初始化完成，用户初始需求已接收 | 采集完成，信息完整性校验通过 | S2 | 3次 |
| S2 | 需求分析 | 调用demand-analysis.skill，生成需求分析报告与验收测试用例 | S1采集完成，结构化需求信息已存入上下文 | 分析完成，报告与测试用例生成完成 | S3 | 2次 |
| S3 | 需求确认 | 调用demand-confirm.skill，完成用户确认闭环 | S2分析完成，需求报告已生成 | 用户确认通过 | S4 | 无限制（用户迭代） |
| | | | | 用户要求修改需求 | S1 | 无限制 |
| S4 | 任务拆解 | 主Agent基于确认的需求报告，拆解为可执行的任务步骤队列 | S3用户确认通过，需求报告已标记为只读 | 任务拆解完成，队列校验通过 | S5 | 2次 |
| S5 | 代码生成 | 调用code-generate.skill，生成代码初稿与单元测试用例 | S4任务拆解完成，任务队列已生成 | 代码生成完成，文件结构校验通过 | S6 | 3次 |
| | | | | 生成失败，可重试 | S5 | 3次 |
| | | | | 生成失败，不可重试 | S4 | 1次 |
| S6 | 错误自愈 | 调用error-fix.skill，检测并修复代码错误 | S5代码生成完成，代码初稿已存入上下文 | 修复完成/安全降级完成 | S7 | 3次 |
| | | | | 无法修复，需重新生成 | S5 | 2次 |
| S7 | 代码标准化 | 调用code-format.skill，统一代码规范与格式 | S6修复完成，代码无致命错误 | 标准化完成，规范校验0错误 | S8 | 2次 |
| S8 | 单元测试 | 调用unit-test.skill，执行单元测试 | S7标准化完成，代码符合规范 | 单元测试通过率100% | S9 | 3次 |
| | | | | 测试不通过，可修复 | S6 | 3次 |
| | | | | 测试不通过，需重新生成 | S5 | 2次 |
| S9 | 文件写入 | 调用file-io.skill，将代码写入项目文件 | S8单元测试通过，测试报告已生成 | 文件写入完成，路径校验通过 | S10 | 3次 |
| S10 | 集成测试 | 调用integration-test.skill，执行集成测试 | S9文件写入完成，项目结构完整 | 集成测试通过 | S11 | 2次 |
| | | | | 测试不通过，可修复 | S6 | 2次 |
| | | | | 测试不通过，需重新生成 | S5 | 1次 |
| S11 | 验收测试 | 调用acceptance-test.skill，执行验收测试 | S10集成测试通过，项目可正常运行 | 验收测试通过率100% | S12 | 3次 |
| | | | | 测试不通过，代码逻辑问题 | S6 | 3次 |
| | | | | 测试不通过，需求理解偏差 | S4 | 2次 |
| | | | | 测试不通过，需求本身矛盾 | S1 | 1次 |
| S12 | 产物交付 | 生成最终交付物，向用户展示交付结果 | S11验收测试通过，所有报告已生成 | 用户确认交付 | S13 | 无限制 |
| | | | | 用户要求重新生成 | S4 | 无限制 |
| S13 | 流程结束 | 清理临时上下文，保存最终快照与日志，流程终止 | S12用户确认交付 | 无 | 终止 | 无 |

---

## 三、异常状态处理规则
### 3.1 重试规则
1.  每个状态的重试次数为该状态的最大重试次数，超过次数后禁止继续重试，按规则流转到对应降级状态
2.  重试仅针对当前状态，不回退到上一个状态，除非规则明确指定
3.  每次重试都必须记录日志、触发事件，标记重试次数与失败原因
4.  连续2次重试失败，自动触发降级逻辑，无需等待达到最大重试次数

### 3.2 超时规则
1.  每个状态定义默认超时时间：
    - 需求类状态：最长5分钟
    - 编码类状态：最长10分钟
    - 测试类状态：最长5分钟
    - 交付类状态：无超时（等待用户操作）
2.  状态执行超过超时时间，自动终止当前执行，按「执行失败」处理，触发重试/降级逻辑
3.  超时事件必须完整记录日志，包含执行时长、当前进度、超时原因

### 3.3 中断与恢复规则
1.  用户手动中断/工具崩溃/系统关机，自动保存当前状态的快照，包含上下文、执行进度、已完成步骤
2.  工具重启后，自动检测未完成的快照，提示用户「从断点恢复」/「重新开始」
3.  从断点恢复时，直接回到中断前的状态，无需重新执行已完成的步骤
4.  恢复后自动校验上下文完整性，缺失数据自动提示用户补充

---

## 四、状态流转校验规则
1.  **禁止跨状态跳转**：仅允许在规则内的相邻状态流转，禁止从S1直接跳转到S5、从S5直接跳转到S11等跨状态操作
2.  **只读状态禁止回退**：S3用户确认通过后，需求报告标记为只读，禁止回退到S1/S2修改需求，除非用户明确发起「需求调整」指令
3.  **测试不通过禁止流转**：S8/S10/S11测试不通过，禁止流转到下一个状态，必须按规则修复/重新生成
4.  **状态流转全留痕**：每次状态流转都必须记录：流转前状态、流转后状态、触发事件、流转时间、操作人员、traceId，存入日志与事件总线
5.  **非法流转拦截**：主Agent状态机引擎自动校验所有状态流转请求，不符合规则的流转直接拦截，记录警告日志，不执行流转操作`,

  'docs/04-项目开发规范与编码准则.md': `# 项目开发规范与编码准则
## 一、总则
本规范为Smart Code Agent项目所有开发人员必须严格遵守的刚性准则，目的是保证代码风格统一、架构边界清晰、职责不越界、可维护性强。任何违反本规范的代码，禁止合并到主分支。

### 1.1 核心原则
1.  **架构边界不可突破**：严格遵守PRD与架构设计文档定义的模块职责，禁止越权开发、禁止突破边界
2.  **单一职责**：每个类、每个函数、每个Skill仅负责一件事，禁止大而全的全能模块
3.  **可测试性**：所有核心逻辑必须可单元测试，禁止硬编码、禁止强耦合
4.  **异常安全**：所有异步操作、IO操作必须有异常捕获，禁止未捕获的异常抛到主流程
5.  **可观测性**：所有核心操作必须有日志、有事件，出问题可追溯、可定位

---

## 二、架构边界规范（宪法级，禁止突破）
### 2.1 主Agent边界规范
1.  主Agent仅负责「状态管控、任务调度、异常兜底、上下文管理」，绝对禁止实现任何业务逻辑
2.  主Agent绝对禁止直接修改代码、生成需求、执行格式化等业务操作，所有业务操作必须通过调用Skill实现
3.  主Agent仅能通过标准化接口调用Skill，禁止直接访问Skill的内部方法、内部属性
4.  主Agent禁止硬编码任何业务规则、业务模板、业务参数，所有业务规则必须放在对应的Skill/资源库中

### 2.2 Skill开发规范
1.  所有Skill必须继承BaseSkill基类，必须实现execute()核心方法，禁止绕过基类直接实现
2.  每个Skill仅负责单一职责，禁止一个Skill实现多个不相关的功能
3.  Skill仅能访问主Agent传入的授权上下文，禁止直接访问全局上下文、禁止修改只读上下文
4.  Skill之间禁止直接通信、直接调用，所有交互必须通过主Agent中转
5.  Skill禁止修改主Agent的状态机、调度逻辑、配置，仅能返回标准化的执行结果
6.  新增Skill必须遵循命名规范：{功能名称}.skill.ts，必须在文件头部注明核心职责、输入、输出

### 2.3 观察者Agent边界规范
1.  观察者Agent仅能通过事件总线单向接收事件，绝对禁止向主流程回发任何指令、任何数据
2.  观察者Agent绝对禁止修改任何上下文、配置、状态、文件，仅能做只读分析、记录、报告生成
3.  观察者Agent的所有逻辑必须全异步执行，绝对不能阻塞主流程的任何操作
4.  观察者Agent禁止访问用户的业务敏感数据，所有接收的事件必须自动脱敏

---

## 三、TypeScript编码规范
1.  **类型安全**：禁止使用any类型，确需使用的必须添加注释说明原因；所有接口、函数参数、返回值必须定义明确的类型
2.  **命名规范**：
    - 类名：大驼峰PascalCase，如BaseSkill、ContextManager
    - 函数/变量/方法：小驼峰camelCase，如execute、contextManager
    - 常量：全大写下划线分隔，如MAX_RETRY_COUNT、DEFAULT_TIMEOUT
    - 文件命名：小写+连字符，如base.skill.ts、context-manager.ts
3.  **代码格式**：必须遵守项目内置的Prettier+ESLint规则，提交代码前必须执行lint:fix与format
4.  **函数规范**：
    - 单个函数长度不超过50行，超过必须拆分为多个子函数
    - 单个函数参数不超过5个，超过必须用对象传递
    - 所有异步函数必须用async/await，禁止回调地狱
    - 所有函数必须有JSDoc注释，说明功能、参数、返回值、异常
5.  **异常处理**：
    - 所有异步操作、IO操作必须包裹try/catch
    - 禁止空的catch块，至少必须记录错误日志
    - 异常必须明确分类，禁止统一捕获所有异常不做处理
    - 业务异常必须返回标准化的错误码与错误信息，禁止直接throw到主流程

---

## 四、Git与版本管理规范
1.  **分支管理**：
    - main分支：保护分支，仅允许通过PR合并，必须经过代码评审
    - dev分支：开发分支，日常开发在此分支进行
    - 功能分支：feature/{功能名称}，单个功能开发在此分支，完成后PR到dev分支
    - 修复分支：fix/{bug描述}，bug修复在此分支，完成后PR到dev分支
2.  **提交规范**：
    - 提交信息必须遵循格式：{type}: {description}
    - type可选值：feat(新增功能)、fix(bug修复)、docs(文档更新)、style(代码格式)、refactor(重构)、test(测试)、chore(工程配置)
    - 提交信息必须清晰描述本次修改的内容，禁止无意义的提交信息
3.  **PR规范**：
    - 单个PR的修改内容不超过500行，超过必须拆分为多个PR
    - PR必须明确描述修改内容、影响范围、测试情况
    - PR必须通过CI的lint、build、test检查，才能进入评审
    - PR必须至少1个评审人通过，才能合并

---

## 五、日志与事件规范
1.  **日志分级规范**：
    - DEBUG：开发调试用的详细信息，生产环境默认关闭
    - INFO：正常的流程流转、状态变化、执行结果
    - WARN：不影响主流程的警告、非核心异常、降级操作
    - ERROR：影响主流程的核心异常、执行失败、重试失败
2.  **日志格式规范**：所有日志必须包含：时间戳、traceId、模块名称、日志级别、日志内容
3.  **事件规范**：
    - 所有核心状态流转、Skill执行、异常操作都必须触发事件
    - 事件必须遵循标准化的事件格式，禁止自定义格式
    - 事件禁止包含用户业务敏感数据，必须自动脱敏
    - 事件必须异步发送，禁止阻塞主流程

---

## 六、测试规范
1.  **单元测试**：所有核心类、核心方法必须编写单元测试，核心逻辑覆盖率必须达到100%
2.  **集成测试**：每个Skill必须编写集成测试，验证输入输出符合标准化协议
3.  **端到端测试**：全流程必须编写端到端测试，覆盖核心场景，验证全流程正常流转
4.  **测试用例规范**：必须包含正常场景、异常场景、边界场景，覆盖所有分支逻辑
5.  提交代码前必须执行所有测试，测试不通过禁止提交

---

## 七、文档规范
1.  新增功能必须同步更新对应的PRD、架构文档、README
2.  所有核心类、核心函数必须有完整的JSDoc注释
3.  新增Skill必须在文档中注明核心职责、输入输出、使用场景
4.  架构变更、核心逻辑变更必须同步更新对应的设计文档
5.  所有文档必须保持与代码同步，禁止出现文档与代码不一致的情况`,

  'docs/05-接口协议与数据结构刚性规范.md': `# 接口协议与数据结构刚性规范
## 一、总则
本规范定义了项目内所有模块间通信、数据交互的唯一标准，所有模块必须严格遵守，禁止自定义协议、自定义数据结构，确保模块间通信零歧义、零兼容问题。

---

## 二、主Agent与Skill通信协议（刚性标准）
### 2.1 标准化输入接口 SkillInput
主Agent调用Skill时，必须传递以下标准化结构，禁止增减核心字段：
\`\`\`typescript
export interface SkillInput {
  /**
   * 全局标准化配置，从配置管理器统一获取
   */
  config: Record<string, any>;

  /**
   * 授权访问的上下文，严格区分只读和可写
   */
  context: {
    /**
     * 只读上下文，Skill仅能读取，禁止任何修改
     * 包含：确认后的需求报告、全局配置、已完成步骤的结果
     */
    readOnly: Record<string, any>;
    /**
     * 可写上下文，Skill仅能修改当前阶段授权的命名空间
     */
    writable: Record<string, any>;
  };

  /**
   * 当前任务的详细描述，从任务队列中获取
   */
  task: {
    /** 任务唯一ID */
    taskId: string;
    /** 任务名称 */
    taskName: string;
    /** 任务核心目标 */
    target: string;
    /** 任务输入参数 */
    params: Record<string, any>;
    /** 任务超时时间（ms） */
    timeout: number;
    /** 最大重试次数 */
    maxRetry: number;
  };

  /**
   * 当前快照的保存路径，用于Skill保存中间状态
   */
  snapshotPath: string;

  /**
   * 全链路追踪ID，单次流程唯一
   */
  traceId: string;
}
\`\`\`

### 2.2 标准化输出接口 SkillOutput
Skill执行完成后，必须返回以下标准化结构，禁止增减核心字段：
\`\`\`typescript
export interface SkillOutput {
  /**
   * 执行结果状态码，仅允许以下4个值
   * 200: 执行成功
   * 300: 需要用户交互，暂停流程等待用户操作
   * 400: 执行失败，可重试
   * 500: 执行失败，不可重试
   */
  code: 200 | 300 | 400 | 500;

  /**
   * 执行结果数据，会自动写入对应阶段的上下文
   * code=200时必须返回，其他状态可选
   */
  data: Record<string, any>;

  /**
   * 执行描述信息，用于日志展示、用户提示
   * 成功/失败都必须填写清晰的描述
   */
  message: string;

  /**
   * 可选：建议的下一步动作，主Agent仅做参考，最终由状态机决定
   */
  nextAction?: string;

  /**
   * 可选：是否需要回滚上一个步骤
   * 默认false，仅当code=500时可设置为true
   */
  needRollback?: boolean;
}
\`\`\`

### 2.3 通信规则
1.  主Agent与Skill之间仅能通过上述标准化接口通信，禁止其他任何形式的数据传递
2.  Skill的run()方法是唯一对外暴露的执行入口，禁止暴露其他内部方法给主Agent
3.  主Agent必须严格校验Skill的输出格式，不符合标准的按code=500处理
4.  所有通信内容必须同步写入日志与事件总线，全链路可追溯
5.  禁止在通信内容中传递大体积文件内容，仅传递文件路径引用

---

## 三、全链路事件总线协议（刚性标准）
### 3.1 标准化事件结构 SystemEvent
所有主流程广播的事件，必须遵循以下结构，禁止增减核心字段：
\`\`\`typescript
export interface SystemEvent {
  /**
   * 事件唯一ID，UUID生成
   */
  eventId: string;

  /**
   * 事件触发时间戳，精确到ms
   */
  timestamp: number;

  /**
   * 触发事件的模块名称，如主Agent、Skill名称
   */
  module: string;

  /**
   * 事件类型，固定枚举值，禁止自定义
   */
  eventType:
    | 'state_change'      // 状态流转
    | 'skill_start'       // Skill开始执行
    | 'skill_success'     // Skill执行成功
    | 'skill_fail'        // Skill执行失败
    | 'skill_retry'       // Skill重试
    | 'context_update'    // 上下文更新
    | 'user_confirm'      // 用户确认操作
    | 'exception_catch'   // 异常捕获
    | 'process_start'     // 流程开始
    | 'process_finish'    // 流程结束
    | 'process_interrupt';// 流程中断

  /**
   * 事件数据，根据事件类型填充对应内容
   * 禁止包含用户业务敏感数据
   */
  data: {
    /** 状态码/执行结果码 */
    statusCode?: number;
    /** 执行耗时（ms） */
    duration?: number;
    /** 重试次数 */
    retryCount?: number;
    /** 事件描述 */
    message?: string;
    /** 额外元数据，禁止包含敏感信息 */
    metadata?: Record<string, any>;
  };

  /**
   * 全链路追踪ID，单次流程唯一
   */
  traceId: string;
}
\`\`\`

### 3.2 事件通信规则
1.  事件总线仅支持「主流程单向广播、观察者单向订阅」的模式，禁止反向通信
2.  所有事件必须异步非阻塞广播，禁止阻塞主流程执行
3.  事件必须严格遵循上述结构，禁止自定义事件类型、自定义字段
4.  事件内容禁止包含用户业务敏感数据、代码内容、需求详情，仅传递系统运行的行为指标
5.  事件广播失败必须静默处理，禁止抛出异常、禁止影响主流程
6.  所有事件必须持久化存储，可按traceId回溯全链路事件

---

## 四、上下文数据结构规范（刚性标准）
### 4.1 上下文命名空间划分
上下文必须按以下命名空间划分，每个命名空间独立存储，严格控制读写权限：
| 命名空间 | 存储内容 | 读写权限 |
|----------|----------|----------|
| init | 工具版本、运行环境、全局配置、traceId | 所有模块只读 |
| demand | 采集的原始需求、需求分析报告、验收测试用例 | 需求分析Skill组可读写，其他模块只读 |
| coding | 任务队列、代码初稿、修复后的代码、标准化代码、单元测试用例 | 编码执行Skill组可读写，其他模块只读 |
| testing | 单元测试报告、集成测试报告、验收测试报告 | 测试验证Skill组可读写，其他模块只读 |
| delivery | 最终交付物清单、文件路径、版本号、交付时间 | 主Agent可读写，其他模块只读 |

### 4.2 上下文操作规则
1.  所有上下文操作必须通过上下文管理器提供的标准化接口，禁止直接操作内存中的上下文对象
2.  上下文更新仅支持增量更新，禁止全量覆盖，更新必须记录日志与事件
3.  确认后的核心数据（如需求报告）必须标记为只读，禁止任何模块修改
4.  模块仅能访问授权的命名空间，越权访问直接拦截，记录警告日志
5.  上下文快照必须每完成一个状态自动保存，持久化到本地

---

## 五、需求分析报告标准化结构
\`\`\`typescript
export interface DemandReport {
  /** 报告唯一ID */
  reportId: string;
  /** 全链路traceId */
  traceId: string;
  /** 生成时间 */
  generateTime: string;
  /** 需求背景与核心目标 */
  demandBackground: {
    background: string;
    coreTarget: string;
  };
  /** 使用场景与用户角色 */
  useScene: {
    targetUser: string;
    coreScenes: string[];
  };
  /** 功能范围 */
  functionScope: {
    coreFunctions: Array<{
      name: string;
      description: string;
    }>;
    secondaryFunctions: Array<{
      name: string;
      description: string;
    }>;
    excludedFunctions: string[];
  };
  /** 技术要求 */
  technicalRequirements: {
    techStack: string;
    language: string;
    uiLibrary?: string;
    runtimeEnv: string;
  };
  /** 验收标准与测试用例 */
  acceptance: {
    acceptanceCriteria: string[];
    testCases: Array<{
      caseId: string;
      caseName: string;
      input: string;
      expectedOutput: string;
      testSteps: string[];
    }>;
  };
  /** 边界条件与约束 */
  boundaryConstraints: {
    boundaryConditions: string[];
    constraints: string[];
  };
  /** 风险提示与建议 */
  riskTips: Array<{
    riskLevel: 'high' | 'medium' | 'low';
    riskDescription: string;
    suggestion: string;
  }>;
}
\`\`\``,

  'docs/06-项目开发里程碑与排期计划.md': `# 项目开发里程碑与排期计划
## 一、项目总周期
总开发周期：8周（56个自然日，40个工作日）
启动日期：2026-02-21
预计上线日期：2026-04-17

---

## 二、分阶段里程碑计划
| 阶段编号 | 阶段名称 | 核心目标 | 周期 | 起止日期 | 交付物 | 验收标准 |
|----------|----------|----------|------|----------|--------|----------|
| 第一阶段 | 地基搭建 | 完成核心框架开发，搭建好架构底座，所有边界规则落地 | 2周 | 2026-02-21 ~ 2026-03-06 | 1. 主Agent核心框架（状态机、上下文管理器、配置管理器、快照管理器）<br>2. BaseSkill基类<br>3. 事件总线、日志系统基础框架<br>4. 项目初始化配置、开发规范文档 | 1. 主Agent状态机流转正常，符合状态机规则<br>2. 上下文权限管控正常，越权访问拦截有效<br>3. BaseSkill基类输入输出校验正常<br>4. 事件总线异步非阻塞广播正常<br>5. 所有代码符合开发规范，单元测试覆盖率100% |
| 第二阶段 | 需求闭环 | 完成需求分析全流程开发，实现需求采集-分析-确认的完整闭环 | 1周 | 2026-03-07 ~ 2026-03-13 | 1. 需求分析Skill组（collect/analysis/confirm）<br>2. 场景化关键问题库<br>3. 需求分析报告模板、验收测试用例模板<br>4. 需求闭环完整流程 | 1. 需求采集可自动识别需求类型，提问精准无冗余<br>2. 需求分析报告生成符合标准化结构，无遗漏<br>3. 用户确认闭环正常，确认后需求报告标记为只读<br>4. 需求修改迭代流程正常，可回流重新采集/分析<br>5. 所有代码符合开发规范，集成测试通过 |
| 第三阶段 | 编码执行 | 完成编码执行全流程开发，实现代码生成-修复-标准化-文件写入的完整流程 | 2周 | 2026-03-14 ~ 2026-03-27 | 1. 编码执行Skill组（generate/error-fix/format/file-io）<br>2. 代码模板库、代码规范规则库<br>3. 错误自愈规则库<br>4. 编码执行完整流程 | 1. 代码生成符合需求报告要求，结构完整<br>2. 错误自愈可自动修复常见语法错误，不可修复的可安全降级<br>3. 代码标准化符合预设规范，0规范错误<br>4. 文件写入按项目结构正常生成，路径正确<br>5. 全流程异常兜底正常，不卡死、不崩溃<br>6. 所有代码符合开发规范，集成测试通过 |
| 第四阶段 | 测试闭环 | 完成测试全流程开发，实现单元测试-集成测试-验收测试的自动化闭环 | 2周 | 2026-03-28 ~ 2026-04-10 | 1. 测试验证Skill组（unit-test/integration/acceptance）<br>2. 测试用例库、自动化测试框架对接<br>3. 循环测试流程<br>4. 测试闭环完整流程 | 1. 单元测试自动生成、自动执行，通过率100%<br>2. 集成测试可自动检查依赖、项目启动、基础功能<br>3. 验收测试可按预设用例自动执行，通过率100%<br>4. 测试不通过可自动回流修复/重新生成，循环测试正常<br>5. 测试报告生成符合标准化结构，内容完整<br>6. 所有代码符合开发规范，集成测试通过 |
| 第五阶段 | 观察者与优化 | 完成观察者Agent开发，完善隐性模块，全流程联调优化 | 1周 | 2026-04-11 ~ 2026-04-17 | 1. 观察者Agent完整模块<br>2. 版本管理、性能监控模块<br>3. 中断与恢复功能<br>4. CLI交互优化<br>5. 全流程联调测试<br>6. 完整项目文档 | 1. 观察者Agent旁路监听正常，全链路事件无遗漏<br>2. 规则分析引擎可正常识别系统问题，输出准确<br>3. 指标计算、报告生成正常<br>4. 中断恢复、版本管理功能正常<br>5. 全流程端到端测试通过，至少3个核心场景跑通<br>6. 全平台兼容正常，Windows/macOS/Linux均可正常运行<br>7. 所有文档完整，与代码同步 |

---

## 三、关键里程碑节点
1.  **里程碑1：架构底座验收**（2026-03-06）：核心框架开发完成，所有架构边界、规则落地，是后续所有开发的基础，此节点不完成，禁止进入后续阶段开发
2.  **里程碑2：需求闭环验收**（2026-03-13）：需求全流程闭环完成，是整个工具的核心差异化能力，此节点验收通过，进入编码执行阶段
3.  **里程碑3：核心功能闭环验收**（2026-03-27）：编码执行全流程完成，工具核心功能跑通，可生成可用的代码
4.  **里程碑4：测试闭环验收**（2026-04-10）：测试全流程自动化闭环完成，交付质量有刚性保障
5.  **里程碑5：全量上线验收**（2026-04-17）：所有功能开发完成，全流程联调通过，可正式发布上线

---

## 四、风险与排期缓冲
1.  每个阶段预留1个工作日的缓冲时间，用于应对突发问题、需求微调
2.  前一个阶段验收不通过，禁止进入下一个阶段，避免问题累积
3.  核心架构变更、核心需求变更，必须重新评估排期，更新里程碑计划
4.  每周五进行进度同步会，评估当前进度，调整后续计划，确保总周期可控`,

  'docs/07-模块开发优先级与依赖关系.md': `# 模块开发优先级与依赖关系
## 一、核心原则
1.  **无依赖优先**：无外部依赖的基础模块优先开发，为上层模块提供支撑
2.  **架构先行**：先开发架构底座模块，再开发业务功能模块，禁止先做业务再补架构
3.  **核心闭环优先**：先完成核心流程的闭环，再开发辅助功能、优化功能
4.  **依赖唯一**：模块间仅允许单向依赖，禁止循环依赖、反向依赖

---

## 二、模块开发优先级与依赖关系总表
| 优先级 | 模块名称 | 所属阶段 | 依赖模块 | 被依赖模块 | 开发说明 |
|--------|----------|----------|----------|------------|----------|
| P0（最高） | 项目初始化配置 | 地基搭建 | 无 | 所有模块 | 最先完成，包含package.json、tsconfig.json、eslint、prettier、gitignore等，所有开发的基础环境 |
| P0 | 日志系统 | 地基搭建 | 项目初始化配置 | 所有模块 | 基础支撑模块，所有模块都需要日志能力，优先开发 |
| P0 | 事件总线 | 地基搭建 | 项目初始化配置、日志系统 | 主Agent、所有Skill、观察者Agent | 全链路事件通信的基础，优先开发 |
| P0 | 上下文管理器 | 地基搭建 | 项目初始化配置、日志系统 | 主Agent、所有Skill | 全链路数据管理的核心，优先开发 |
| P0 | 配置管理器 | 地基搭建 | 项目初始化配置、日志系统 | 主Agent、所有Skill | 全局配置统一管理，所有模块都需要，优先开发 |
| P0 | 状态机引擎 | 地基搭建 | 项目初始化配置、日志系统、事件总线 | 主Agent | 全流程流转的核心，主Agent的核心依赖，必须优先开发 |
| P0 | BaseSkill基类 | 地基搭建 | 项目初始化配置、日志系统、事件总线 | 所有Skill | 所有Skill的基类，必须在所有Skill开发前完成 |
| P0 | 快照管理器 | 地基搭建 | 项目初始化配置、日志系统、上下文管理器 | 主Agent | 中断恢复、状态快照的核心，主Agent的依赖，P0级完成 |
| P0 | 主Agent核心框架 | 地基搭建 | 状态机引擎、上下文管理器、配置管理器、快照管理器、事件总线、BaseSkill基类 | 所有Skill、所有业务流程 | 整个系统的唯一调度中枢，地基搭建阶段的核心交付物，P0级必须完成 |
| P1 | 场景化关键问题库 | 需求闭环 | 无 | demand-collect.skill | 需求采集的基础资源，P1级优先开发 |
| P1 | 需求分析报告模板 | 需求闭环 | 无 | demand-analysis.skill | 需求分析的基础资源，P1级优先开发 |
| P1 | demand-collect.skill | 需求闭环 | BaseSkill基类、关键问题库 | demand-analysis.skill | 需求闭环的第一个环节，P1级优先开发 |
| P1 | demand-analysis.skill | 需求闭环 | demand-collect.skill、需求报告模板 | demand-confirm.skill | 需求分析核心环节，P1级开发 |
| P1 | demand-confirm.skill | 需求闭环 | demand-analysis.skill | 主Agent | 需求闭环的最后一个环节，P1级开发 |
| P2 | 代码模板库 | 编码执行 | 无 | code-generate.skill | 代码生成的基础资源，P2级优先开发 |
| P2 | 代码规范规则库 | 编码执行 | 无 | code-format.skill | 代码标准化的基础，P2级开发 |
| P2 | 错误自愈规则库 | 编码执行 | 无 | error-fix.skill | 错误修复的基础，P2级开发 |
| P2 | code-generate.skill | 编码执行 | BaseSkill基类、代码模板库 | error-fix.skill | 编码执行的核心环节，P2级优先开发 |
| P2 | error-fix.skill | 编码执行 | code-generate.skill、错误自愈规则库 | code-format.skill | 错误自愈核心环节，P2级开发 |
| P2 | code-format.skill | 编码执行 | error-fix.skill、代码规范规则库 | unit-test.skill | 代码标准化环节，P2级开发 |
| P2 | file-io.skill | 编码执行 | BaseSkill基类 | integration-test.skill | 文件写入环节，P2级开发 |
| P3 | 测试用例库 | 测试闭环 | 无 | 所有测试Skill | 自动化测试的基础资源，P3级优先开发 |
| P3 | unit-test.skill | 测试闭环 | BaseSkill基类、测试用例库 | file-io.skill | 单元测试环节，P3级优先开发 |
| P3 | integration-test.skill | 测试闭环 | file-io.skill | acceptance-test.skill | 集成测试环节，P3级开发 |
| P3 | acceptance-test.skill | 测试闭环 | integration-test.skill | 主Agent | 验收测试环节，P3级开发 |
| P4 | 观察者事件监听引擎 | 观察者模块 | 事件总线 | 所有观察者子模块 | 观察者的基础，P4级优先开发 |
| P4 | 观察者规则分析引擎 | 观察者模块 | 事件监听引擎、观察者规则库 | 报告生成模块 | 问题识别核心，P4级开发 |
| P4 | 观察者指标计算模块 | 观察者模块 | 事件监听引擎 | 报告生成模块 | 指标计算核心，P4级开发 |
| P4 | 观察者报告生成模块 | 观察者模块 | 规则分析引擎、指标计算模块 | 数据持久化模块 | 报告生成核心，P4级开发 |
| P4 | 观察者数据持久化模块 | 观察者模块 | 所有观察者子模块 | 无 | 数据存储环节，P4级开发 |
| P4 | 版本管理模块 | 优化完善 | 快照管理器、上下文管理器 | CLI交互模块 | 版本回退、历史版本管理，P4级开发 |
| P4 | 性能监控模块 | 优化完善 | 事件总线、指标计算模块 | 报告生成模块 | 性能监控、瓶颈分析，P4级开发 |
| P4 | CLI交互优化 | 优化完善 | 主Agent、所有模块 | 无 | 用户交互优化、状态展示、报告查看，P4级最后开发 |

---

## 三、依赖关系规则（刚性禁止突破）
1.  **禁止反向依赖**：下层模块禁止依赖上层模块，比如BaseSkill基类禁止依赖具体的Skill，主Agent禁止依赖观察者Agent
2.  **禁止循环依赖**：模块间禁止出现A依赖B、B依赖A的循环依赖，所有依赖必须是单向的
3.  **禁止跨层级依赖**：业务Skill禁止直接依赖状态机引擎、上下文管理器的内部实现，只能通过主Agent传递的标准化接口访问
4.  **禁止隐式依赖**：所有依赖必须在package.json、import中明确声明，禁止隐式依赖、全局变量依赖
5.  **最小依赖原则**：每个模块仅依赖必须的最小模块，禁止引入不必要的依赖

---

## 四、开发顺序建议
严格按照以下顺序开发，避免依赖阻塞：
1.  第一批次（P0）：项目初始化配置 → 日志系统 → 事件总线 → 上下文管理器 → 配置管理器 → 状态机引擎 → BaseSkill基类 → 快照管理器 → 主Agent核心框架
2.  第二批次（P1）：关键问题库 → 需求报告模板 → demand-collect.skill → demand-analysis.skill → demand-confirm.skill
3.  第三批次（P2）：代码模板库 → 代码规范规则库 → 错误自愈规则库 → code-generate.skill → error-fix.skill → code-format.skill → file-io.skill
4.  第四批次（P3）：测试用例库 → unit-test.skill → integration-test.skill → acceptance-test.skill
5.  第五批次（P4）：观察者模块 → 版本管理模块 → 性能监控模块 → CLI交互优化

---

## 五、并行开发说明
1.  同优先级的无依赖模块可并行开发，比如P0级的日志系统、事件总线可并行开发
2.  资源类模块（问题库、模板库、规则库）可与对应的Skill并行开发，比如关键问题库可与demand-collect.skill并行开发
3.  观察者模块完全独立于主流程，可与主流程的P2/P3阶段并行开发，不阻塞主流程闭环
4.  优化完善类模块（版本管理、性能监控）必须在主流程全闭环完成后再开发，禁止提前开发阻塞核心功能`,

  'docs/08-项目风险清单与应对预案.md': `# 项目风险清单与应对预案
## 一、风险评估标准
- 风险概率：高（>70%）、中（30%-70%）、低（<30%）
- 影响程度：高（导致项目延期/架构重构/核心功能不可用）、中（导致模块返工/开发阻塞）、低（不影响核心流程，仅需微调）
- 风险等级：
  - 红色风险：高概率+高影响，必须提前制定预案，重点防控
  - 橙色风险：高概率+中影响 / 中概率+高影响，必须提前关注，制定应对方案
  - 黄色风险：中概率+中影响 / 高概率+低影响 / 低概率+高影响，提前制定预防措施
  - 蓝色风险：低概率+中影响 / 中概率+低影响，常规关注即可

---

## 二、全周期风险清单与应对预案
| 风险编号 | 风险类型 | 风险描述 | 概率 | 影响程度 | 风险等级 | 预防措施 | 应对预案 |
|----------|----------|----------|------|----------|----------|----------|----------|
| R01 | 架构风险 | 主Agent职责边界被突破，逐渐变成全能臃肿体，导致架构混乱、维护成本飙升 | 高 | 高 | 红色 | 1. PRD与架构文档明确主Agent职责红线，写入开发规范<br>2. 代码评审时重点检查主Agent是否包含业务逻辑<br>3. 主Agent核心代码稳定后，设置为保护模块，禁止随意修改<br>4. 新增功能必须通过Skill实现，禁止修改主Agent核心逻辑 | 1. 立即暂停主Agent代码修改，发起架构评审<br>2. 将越界的业务逻辑剥离为独立Skill<br>3. 重构主Agent核心代码，回归单一职责<br>4. 更新开发规范，增加更严格的边界校验 |
| R02 | 流程风险 | 状态机流转异常，出现死循环、非法跳转、流程卡死，导致主流程不可用 | 中 | 高 | 橙色 | 1. 状态机规则刚性定义，禁止非法流转<br>2. 每个状态设置最大重试次数，超过阈值自动终止<br>3. 状态流转前强制校验准入条件，不满足禁止流转<br>4. 所有状态流转全留痕，可追溯 | 1. 立即触发异常兜底，终止当前流程，保存快照<br>2. 自动分析流转异常的原因，提示用户<br>3. 提供「从断点恢复」/「重新开始」选项<br>4. 修复状态机规则，补充边界校验 |
| R03 | 稳定性风险 | Skill执行异常、未捕获的异常，导致主流程崩溃、卡死 | 高 | 高 | 红色 | 1. BaseSkill基类封装统一的异常捕获逻辑，禁止异常抛到主流程<br>2. 所有异步操作、IO操作必须有try/catch<br>3. 主Agent执行调度时包裹全局异常捕获<br>4. 每个Skill设置超时时间，超过自动终止 | 1. 异常自动捕获，记录完整错误日志<br>2. 按异常等级触发重试/降级/回滚策略<br>3. 绝对不卡死，向用户提示错误原因，提供重试入口<br>4. 修复Skill的异常处理逻辑 |
| R04 | 需求风险 | 开发过程中核心需求、架构频繁变更，导致开发返工、项目延期 | 中 | 高 | 橙色 | 1. 开发前锁定PRD核心需求、架构设计，全员确认<br>2. 明确需求变更管理规则，核心需求变更必须发起正式评审<br>3. 分阶段开发，每个阶段需求锁定，禁止中途变更<br>4. 非核心需求放到后续迭代，不影响主周期 | 1. 评估变更影响范围、对排期的影响<br>2. 发起正式评审，全员确认通过后，更新PRD与文档<br>3. 调整开发计划，将变更放到下一个迭代，或调整当前排期<br>4. 禁止未经评审的需求变更直接进入开发 |
| R05 | 性能风险 | 全流程执行耗时过长、内存占用过高，导致用户体验差、工具不可用 | 中 | 中 | 黄色 | 1. 所有事件、日志异步非阻塞执行，不阻塞主流程<br>2. 上下文冷热数据分级存储，避免内存溢出<br>3. Skill动态懒加载，启动时不加载所有模块<br>4. 模板预编译，避免每次执行实时解析<br>5. 性能监控模块提前开发，监控每个环节的耗时 | 1. 通过性能监控定位耗时瓶颈、内存占用高的模块<br>2. 针对瓶颈模块做专项优化，比如并行执行、缓存复用<br>3. 优化大体积数据处理逻辑，避免全量拷贝<br>4. 增加执行进度提示，优化用户等待体验 |
| R06 | 通信风险 | 模块间通信协议不统一、数据结构不一致，导致模块间兼容问题、数据丢失 | 中 | 中 | 黄色 | 1. 提前定义刚性的接口协议与数据结构规范，全员严格遵守<br>2. 所有输入输出必须经过格式校验，不符合的直接拦截<br>3. 模块间通信全留痕，可追溯<br>4. 每个Skill必须编写集成测试，验证输入输出符合协议 | 1. 立即定位协议不一致的地方，统一更新为标准格式<br>2. 修复对应模块的输入输出逻辑<br>3. 补充格式校验逻辑，避免后续再次出现<br>4. 补充对应的集成测试用例 |
| R07 | 数据安全风险 | 工具上传用户业务数据、代码到外部服务，导致数据泄露 | 低 | 高 | 黄色 | 1. 明确所有数据本地存储，禁止上传任何外部服务<br>2. 代码审查时检查所有网络请求，禁止未授权的外部请求<br>3. 事件、日志自动脱敏，禁止存储用户业务敏感数据<br>4. 提供私有化部署方案，所有数据完全在用户本地 | 1. 立即移除未授权的网络请求<br>2. 发布紧急修复版本<br>3. 向用户说明情况，提供数据清理方案<br>4. 补充网络请求审计机制，禁止未授权的外部请求 |
| R08 | 兼容风险 | 工具在不同平台、不同Node.js版本下运行异常，兼容性差 | 中 | 中 | 黄色 | 1. 明确兼容范围：Node.js 16+ LTS，Windows/macOS/Linux全平台<br>2. 避免使用平台专属的API、Node.js版本专属API<br>3. CI/CD中增加多平台、多版本的自动化测试<br>4. 依赖包选择跨平台兼容的稳定版本，避免使用原生依赖 | 1. 定位兼容问题的原因，替换为跨平台兼容的实现方案<br>2. 补充对应平台/版本的自动化测试<br>3. 更新兼容范围说明，明确支持的版本与平台 |
| R09 | 项目管理风险 | 开发进度滞后，导致项目延期 | 中 | 中 | 黄色 | 1. 分阶段里程碑管理，每个阶段明确交付物与验收标准<br>2. 每周进度同步，及时发现滞后风险<br>3. 每个阶段预留缓冲时间，应对突发问题<br>4. 优先级明确，核心功能优先开发，非核心功能后置 | 1. 评估进度滞后的原因，调整开发计划<br>2. 优先保障核心功能开发，非核心功能放到后续迭代<br>3. 增加开发资源，追赶进度<br>4. 重新评估里程碑节点，更新排期计划 |
| R10 | 可维护性风险 | 代码不规范、无注释、无文档，导致后续维护成本高、迭代困难 | 高 | 中 | 橙色 | 1. 制定严格的开发规范与编码准则，全员严格遵守<br>2. 提交代码前必须执行lint、format，不通过禁止提交<br>3. 所有核心类、核心函数必须有完整的注释<br>4. 新增功能必须同步更新文档，文档与代码保持一致<br>5. 代码评审必须检查代码规范、注释、文档 | 1. 组织代码重构，统一代码风格，补充注释与文档<br>2. 补充单元测试、集成测试<br>3. 加强代码评审力度，不规范的代码禁止合并<br>4. 组织开发规范培训，统一开发标准 |

---

## 三、红色风险重点防控措施
针对R01、R03两个红色风险，制定专项防控措施：
### 3.1 R01 主Agent职责边界突破防控
1.  成立架构评审小组，所有主Agent的代码修改必须经过评审小组审核通过，才能合并
2.  在CI/CD中增加自动化检查，检测主Agent代码中是否包含业务逻辑，不通过禁止合并
3.  主Agent核心代码仅允许架构负责人修改，其他开发人员无修改权限
4.  每周架构巡检，检查主Agent代码是否符合职责边界要求，发现问题立即整改

### 3.2 R03 主流程崩溃卡死防控
1.  所有Skill必须100%覆盖异常场景的单元测试，不通过禁止合并
2.  BaseSkill基类的异常捕获逻辑禁止修改，所有Skill必须继承基类，禁止绕过基类执行
3.  主Agent的全局异常捕获逻辑为保护代码，禁止修改、禁止移除
4.  全流程端到端测试必须覆盖所有异常场景，验证异常兜底逻辑正常
5.  每个Skill必须设置超时时间，主Agent必须实现超时强制终止逻辑，禁止无限等待

---

## 四、风险应急响应流程
1.  **风险上报**：发现风险后，立即上报项目负责人，记录风险详情、影响范围
2.  **风险评估**：项目负责人组织相关人员，评估风险等级、影响范围、紧急程度
3.  **预案执行**：按本预案的应对方案，执行应急处理，控制风险影响
4.  **进度同步**：应急处理过程中，实时同步处理进度，及时调整方案
5.  **复盘优化**：风险处理完成后，组织复盘，更新风险清单与预防措施，避免再次发生`,

  'docs/项目目录结构说明书.md': `# 项目目录结构说明书
## 项目根目录
\`\`\`
smart-code-agent/
├── docs/                           # 项目全套文档
├── src/                            # 项目源码目录
├── package.json                    # 项目依赖、脚本、全局配置
├── tsconfig.json                   # TypeScript编译配置
├── .eslintrc.js                    # ESLint代码规范配置
├── .prettierrc                     # Prettier代码格式配置
├── .gitignore                      # Git忽略文件配置
└── README.md                       # 项目全局说明文档
\`\`\`

---

## 目录详细说明
### 1. docs/ 目录
存放项目所有的设计文档、开发规范、PRD、排期计划等，所有文档必须与代码保持同步更新。
| 文件名 | 核心用途 |
|--------|----------|
| 00-项目README.md | 项目全局说明、核心定位、架构总览、快速入门 |
| 01-产品需求文档(PRD) V3.1 最终定稿版.md | 需求唯一标准，开发边界、功能范围、交付标准刚性定义 |
| 02-系统架构设计说明书 最终版.md | 架构唯一标准，模块职责、通信规则、边界红线、数据流转 |
| 03-全流程状态机与流转规则说明书.md | 流程唯一标准，刚性定义状态流转、准入准出、异常处理 |
| 04-项目开发规范与编码准则.md | 团队开发统一标准，避免代码混乱、职责越界 |
| 05-接口协议与数据结构刚性规范.md | 模块间通信、输入输出、事件、上下文的唯一格式标准 |
| 06-项目开发里程碑与排期计划.md | 分阶段开发节奏、交付物、验收标准 |
| 07-模块开发优先级与依赖关系.md | 开发顺序、依赖关系，避免开发阻塞 |
| 08-项目风险清单与应对预案.md | 开发&运行全周期风险前置、兜底方案 |
| 项目目录结构说明书.md | 本文档，每个目录/文件的法定职责 |

### 2. src/ 目录
项目源码根目录，所有业务代码、核心逻辑都在此目录下。

#### 2.1 src/bin/ 目录
CLI命令行入口目录，全局命令注册、启动入口。
| 文件名 | 核心职责 |
|--------|----------|
| index.ts | 全局命令注册、参数解析、指令分发、工具启动入口 |

#### 2.2 src/agent/ 目录
所有Agent模块的根目录，包含主Agent、需求分析师Agent、观察者Agent，是整个系统的大脑。

##### 2.2.1 src/agent/main/ 目录
主Agent核心模块，全流程唯一调度中枢，仅负责调度，不执行业务逻辑。
| 文件名 | 核心职责 |
|--------|----------|
| index.ts | 主Agent入口，对外暴露唯一的启动、调度接口 |
| state-machine.ts | 全流程状态机引擎，状态流转管控、规则校验 |
| planner.ts | 任务规划器，需求拆解、任务队列生成、并行/串行编排 |
| executor.ts | 执行调度器，Skill动态加载、调度执行、超时管控 |
| exception-handler.ts | 异常兜底器，全流程异常捕获、分级处理、重试/降级/回滚 |

##### 2.2.2 src/agent/demand-analyst/ 目录
需求分析师Agent模块，负责需求采集-分析-确认闭环，仅处理需求相关业务，不干预编码流程。
| 文件名 | 核心职责 |
|--------|----------|
| index.ts | 需求分析师Agent入口，对外暴露标准化的执行接口 |
| collect.ts | 需求采集控制器，匹配关键问题库、引导用户补充需求信息 |
| analysis.ts | 需求分析报告生成器，生成标准化需求报告与验收测试用例 |
| confirm.ts | 需求确认控制器，用户确认闭环、需求迭代调整 |

##### 2.2.3 src/agent/observer/ 目录
观察者Agent模块，旁路只读监听，不干预主流程，仅负责监控、分析、记录、报告生成。
| 文件名 | 核心职责 |
|--------|----------|
| index.ts | 观察者Agent入口，启动/停止监听、报告生成入口 |
| event-listener.ts | 事件监听引擎，订阅事件总线、事件格式化、过滤、聚合 |
| rule-engine.ts | 规则分析引擎，基于预设规则识别系统问题、根因分析 |
| metric-calc.ts | 指标计算模块，全链路量化指标计算、聚合、异常预警 |
| report-generator.ts | 报告生成模块，标准化报告生成、导出 |
| storage.ts | 数据持久化模块，事件、指标、日志、报告的结构化存储 |

##### 2.2.4 src/agent/ 根目录文件
| 文件名 | 核心职责 |
|--------|----------|
| memory.ts | 全链路内存管理，上下文的全局存储 |
| context-manager.ts | 上下文管理器，分阶段命名空间管理、权限管控、增量更新 |
| config-manager.ts | 配置管理器，全局配置的加载、合并、校验、分发 |
| snapshot-manager.ts | 快照管理器，状态快照的保存、加载、恢复、清理 |

#### 2.3 src/skills/ 目录
所有Skill插件的根目录，所有业务执行逻辑都在此目录，每个Skill单一职责，可插拔、可扩展。
| 文件名 | 核心职责 |
|--------|----------|
| base.skill.ts | Skill基类，所有Skill必须继承，封装标准化输入输出、格式校验、异常捕获 |
| demand-collect.skill.ts | 需求采集Skill，场景化提问、信息采集、完整性校验 |
| demand-analysis.skill.ts | 需求分析Skill，需求报告生成、验收用例生成、风险识别 |
| demand-confirm.skill.ts | 需求确认Skill，报告推送、用户确认、需求迭代 |
| code-generate.skill.ts | 代码生成Skill，基于需求报告生成代码初稿、单元测试用例 |
| error-fix.skill.ts | 错误自愈Skill，代码错误检测、自动修复、安全降级 |
| code-format.skill.ts | 代码标准化Skill，代码格式化、规范统一、注释补充 |
| unit-test.skill.ts | 单元测试Skill，单元测试执行、测试报告生成 |
| file-io.skill.ts | 文件操作Skill，代码文件写入、项目结构生成 |
| integration-test.skill.ts | 集成测试Skill，依赖检查、项目启动检查、基础功能验证 |
| acceptance-test.skill.ts | 验收测试Skill，验收用例执行、验收报告生成 |

#### 2.4 src/utils/ 目录
通用工具函数目录，所有无业务逻辑的通用工具都在此目录，禁止在工具函数中实现业务逻辑。
| 文件名 | 核心职责 |
|--------|----------|
| event-bus.ts | 全链路异步事件总线，主流程事件单向广播 |
| logger.ts | 统一日志系统，分级日志、格式化输出、异步落盘 |
| validator.ts | 通用校验工具，输入格式、数据结构、完整性校验 |
| helper.ts | 通用辅助函数，字符串、日期、文件路径等通用处理 |

#### 2.5 src/assets/ 目录
静态资源目录，所有模板、规则库、问题库都在此目录，禁止存放业务代码。

##### 2.5.1 src/assets/question-lib/ 目录
场景化关键问题库，不同需求类型的提问模板。
| 文件名 | 核心用途 |
|--------|----------|
| page.ts | 页面开发场景的关键问题库 |
| api.ts | 接口开发场景的关键问题库 |
| component.ts | 组件封装场景的关键问题库 |
| project.ts | 项目初始化场景的关键问题库 |

##### 2.5.2 src/assets/templates/ 目录
所有模板文件目录。
| 目录名 | 核心用途 |
|--------|----------|
| demand-report/ | 需求分析报告模板、验收测试用例模板 |
| code/ | 各技术栈代码模板、项目结构模板 |
| observer-report/ | 观察者报告模板、指标报告模板 |

##### 2.5.3 src/assets/rules/ 目录
所有规则库目录。
| 文件名 | 核心用途 |
|--------|----------|
| eslint.ts | ESLint代码规范规则 |
| prettier.ts | Prettier格式化规则 |
| naming.ts | 命名规范规则 |
| observer-rules.ts | 观察者分析规则库 |

#### 2.6 src/config/ 目录
全局配置目录，默认配置、自定义配置的定义都在此目录。
| 文件名 | 核心用途 |
|--------|----------|
| default.ts | 系统默认配置，所有配置的默认值 |
| observer.config.ts | 观察者Agent专属配置 |

#### 2.7 src/index.ts
项目主入口，对外暴露核心API，用于二次开发、模块引入。

---

## 目录管理规则
1.  **禁止随意新增目录**：新增顶层目录必须发起架构评审，全员确认通过
2.  **职责单一**：每个目录仅负责单一类别的内容，禁止跨目录存放文件
3.  **命名规范**：所有目录、文件命名必须遵循小写+连字符的规范，禁止大驼峰、下划线
4.  **禁止冗余文件**：禁止存放未使用的文件、临时文件、测试文件到src目录
5.  **文档同步**：目录结构变更必须同步更新本文档`,
};

// 3. 批量写入所有文件
console.log('开始生成项目文件...');
Object.entries(files).forEach(([filePath, content]) => {
  const fullPath = path.join(ROOT_PATH, filePath);
  fs.writeFileSync(fullPath, content, 'utf8');
  console.log(`生成文件: ${fullPath}`);
});

// 4. 生成src目录下的初始化占位文件，确保目录结构完整
const srcPlaceholderFiles = {
  'src/bin/index.ts': `#!/usr/bin/env node
import { program } from 'commander';
import packageJson from '../../package.json';

program
  .version(packageJson.version)
  .description('Smart Code Agent - 智能代码规范化自动生成工具')
  .command('start', '启动工具，开始生成代码')
  .command('resume', '恢复中断的流程')
  .command('report', '查看系统运行报告')
  .parse(process.argv);`,

  'src/index.ts': `export * from './agent/main';
export * from './agent/demand-analyst';
export * from './agent/observer';
export * from './skills/base.skill';`,

  'src/agent/main/index.ts': `export class MainAgent {
  // 主Agent核心实现
}`,

  'src/skills/base.skill.ts': `// BaseSkill基类完整实现见docs/02-系统架构设计说明书.md
export abstract class BaseSkill {
  public abstract readonly name: string;
  protected abstract execute(input: any): Promise<any>;
  public async run(input: any): Promise<any> {
    // 统一执行逻辑
  }
}`,

  'src/utils/event-bus.ts': `// 事件总线完整实现见docs/02-系统架构设计说明书.md
class SystemEventBus {
  private static instance: SystemEventBus;
  private constructor() {}
  public static getInstance(): SystemEventBus {
    if (!SystemEventBus.instance) {
      SystemEventBus.instance = new SystemEventBus();
    }
    return SystemEventBus.instance;
  }
  public emitEvent(event: any): void {
    // 异步事件广播
  }
  public subscribeEvent(callback: (event: any) => void): void {
    // 事件订阅
  }
}
export default SystemEventBus.getInstance();`,
};

Object.entries(srcPlaceholderFiles).forEach(([filePath, content]) => {
  const fullPath = path.join(ROOT_PATH, filePath);
  if (!fs.existsSync(path.dirname(fullPath))) {
    fs.mkdirSync(path.dirname(fullPath), { recursive: true });
  }
  fs.writeFileSync(fullPath, content, 'utf8');
  console.log(`生成占位文件: ${fullPath}`);
});

console.log('');
console.log('✅ 项目文件生成完成！');
console.log(`📦 项目根目录: ${ROOT_PATH}`);
console.log('');
console.log('📖 使用说明:');
console.log('1. 进入项目目录: cd smart-code-agent-full-package');
console.log('2. 安装依赖: npm install');
console.log('3. 开发模式: npm run dev');
console.log('4. 构建项目: npm run build');
console.log('');
console.log('📚 全套文档已生成在 docs/ 目录下，开发前请仔细阅读');